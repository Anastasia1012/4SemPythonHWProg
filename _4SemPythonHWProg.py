#1. Задайте натуральное число N. Напишите программу, которая составит список простых множителей числа N.
#вариент 1
#def primfacs(n):
#   i = 2
#   primfac = []
#   while i * i <= n:
#       while n % i == 0:
#           primfac.append(i)
#           n = n / i
#       i = i + 1
#   if n > 1:
#       primfac.append(n)
#    return primfac

#вариант 2
#from array import array


#n = int(input())
#i = 2
#while n > 1:
#    while n % i == 0:
#        print(i, end=' ')
#        n //= i
#    i += 1

#    2 - Задайте последовательность чисел. Напишите программу, 
#    которая выведет список неповторяющихся элементов исходной последовательности. Не использовать множества.
#[1,1,1,1,2,2,2,3,3,3,4] -> [1,2,3,4]

a = [1,2,2,2,3,4,5,5,5]
print(tuple(sorted(filter(lambda x : a.count(x) == 1, a))))
(1, 3, 4)

#3 - В файле, содержащем фамилии студентов и их оценки, изменить на прописные буквы фамилии тех студентов, которые имеют средний балл более «4».
#Нужно перезаписать файл.
#Пример:
#Ангела Меркель 5
#Андрей Валетов 5
#Фредди Меркури 3
#Анастасия Пономарева 4

#Программа выдаст:
#АНГЕЛА МЕРКЕЛЬ 5
#АНДРЕЙ ВАЛЕТОВ 5
#Фредди Меркури 3
#Анастасия Пономарева 4

#4- Шифр Цезаря - это способ шифрования, где каждая буква смещается на определенное количество символов влево или вправо. 
#При расшифровке происходит обратная операция. 
#К примеру, слово "абба" можно зашифровать "бввб" - сдвиг на 1 вправо. "вггв" - сдвиг на 2 вправо, "юяяю" - сдвиг на 2 влево.
#Сдвиг часто называют ключом шифрования.
#Ваша задача - написать функцию, которая записывает в файл шифрованный текст, 
#а также функцию, которая спрашивает ключ, считывает текст и дешифровывает его.


alfavit_EU =  'ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ'
alfavit_RU = 'АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯАБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ'
smeshenie = int(input('Шаг шифровки: '))
message = input("Сообщение для ДЕшифровки: ").upper()
itog = ''
lang = input('Выберите язык RU/EU: ')
if lang == 'RU':
    for i in message:
        mesto = alfavit_RU.find(i)
        new_mesto = mesto + smeshenie
        if i in alfavit_RU:
            itog += alfavit_RU[new_mesto]
        else:
            itog += i
else:
    for i in message:
        mesto = alfavit_EU.find(i)
        new_mesto = mesto + smeshenie
        if i in alfavit_EU:
            itog += alfavit_EU[new_mesto]
        else:
            itog += i
print (itog)

#5 - Реализуйте RLE алгоритм: реализуйте модуль сжатия и восстановления данных. 
#Входные и выходные данные хранятся в отдельных текстовых файлах.
#файл первый:
#AAAAAAAAAAAABBBBBBBBBBBCCCCCCCCCCDDDDDDEEEEEFFFFG python is sooooooo coooooool
#файл второй:
#сжатый текст.
# Выполнение алгоритма сжатия данных кодирования длин серий (RLE) для строки `str`
def encode(s):
 
    encoding = "" # сохраняет выходную строку
 
    i = 0
    while i < len(s):
        # подсчитывает количество вхождений символа в индексе `i`
        count = 1
 
        while i + 1 < len(s) and s[i] == s[i + 1]:
            count = count + 1
            i = i + 1
 
        # добавляет к результату текущий символ и его количество
        encoding += str(count) + s[i]
        i = i + 1
 
    return encoding
 
 
if __name__ == '__main__':
 
    s = 'ABBCCCD'
    print(encode(s))